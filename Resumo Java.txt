- Algoritmo

	Sequência finita de instruções para se resolver um problema, aplicando-se a diversas áreas de conhecimento.

- Automação

	Consiste em utilizar uma máquina para executar o procedimento desejado de forma automática ou semiautomática.

- Computador

	Um computador é composto por:

	Hardware - parte física (as peças)
	Software - parte lógica (os programas)

- Programa de computador

	Programas de computador são algoritmos executados pelo computador.

	O computador é uma máquina que automatiza a execução de algoritmos.

	Porém funciona apenas para algoritmos computacionais como processamento de dados e cálculos.

- O que é preciso para se fazer um programa de computador

	Vamos precisar de:

	Uma linguagem de programação
	Uma IDE (Integrated Development Environment ou Ambiente de Desenvolvimento Integrado)
	Um compilador
	Um gerador de código ou máquina virtual

- Linguagem de programação

	É um conjunto de regras léxicas (ortografia) e sintáticas (gramática) para se escrever programas.

	Léxica diz respeito à correção das palavras "isoladas" (ortografia).

	Sintática diz respeito à correção das sentenças (gramática).

	Exemplos de linguagens de programação: C, Pascal, C++, Java, C#, Python, Ruby, PHP, JavaScript, etc.

- IDE

	IDE significa "Integrated Development Environment" ou traduzindo "Ambiente de Desenvolvimento Integrado".

	É um conjunto de softwares utilizado para a construção de programas, exemplos:

	C/C++ - Code Blocks
	Java -  Eclipse, NetBeans
	C# - Microsoft Visual Studio

	Funcionalidades de uma IDE:

	Edição de código fonte (indentação, autocompletar, destaque de palavras, etc.)
	Depuração e testes
	Construção do produto final
	Sugestão de modelos
	Auxiliar em várias tarefas do seu projeto

- Código fonte

	É aquele escrito pelo programador em linguagem de programação na construção dos programas.

- Modos de construção de programas

	Compilação
	Interpretação
	Abordagem híbrida

- Compilação

	cria o código fonte > passa pelo compilador (análise léxica e análise sintática) > que cria o código objeto > passa pelo gerador de código > que cria o código executavel específico > que é executado pelo S.O.

	Exemplos de linguagem: C, C++

- Interpretação

	cria o código fonte > passa pelo interpretador (que faz a geração de código sob demanda) > que é executado pelo S.O.

	Exemplos de linguagem: PHP, JavaScript

- Abordagem híbrida

	cria o código fonte > passa pelo pré-compilador (análise léxica e análise sintática) > que cria o código objeto (Bytecode em Java) > passa pela máquina virtual (que faz a geração de código sob demanda) > que é executado pelo S.O.

	Exemplos de linguagem: Java, C#

- Vantagens e desvantagens dos modos de construção de programas

	Compilação

	Vantagens: alta velocidade de execução do programa, auxilio do compilador na checagem do programa
	Desvantagens: necessidade de compilar para cada S.O., pode ser necessario alterar partes dos códigos dependendo do S.O., precisa ser recompilado caso seja alterado

	Interpretação

	Vantagens: não precisa compilar para cada S.O.
	Desvantagens: baixa velocidade de execução do programa, não temos auxilio do compilador na checagem do programa

	Abordagem híbrida

	Vantagens: não precisa compilar para cada S.O., auxilio do compilador na checagem do programa
	Desvantagens: média velocidade de execução do programa, precisa ser recompilado caso seja alterado

- Java

	É uma linguagem de programação, plataforma de desenvolvimento e execução de programas.

	Criada pela Sun Microsystems no meio da década de 1990 e adquirida pela Oracle Corporation em 2010.

	Desenhada para ser utilizada em todos os tipos de dispositivos, principalmente portáteis.

	É uma linguagem orientada a objetos, segura, robusta e que domina o mercado a muitos anos.

	Resolve problemas de linguagens antigas como ponteiros / gerenciamento de memória, portabilidade, utilização em dispositivos diversos e custo.

- Versões do Java

	LTS ("Long Term Support" ou "suporte de longo prazo") - são versões com maior tempo de updates, correções e suporte tecnico por parte do fabricante. Elas são lançadas com menor frequencia.

	Non-LTS - são versões com menor tempo de updates, correções e suporte tecnico por parte do fabricante. Elas são lançadas com menor frequencia, normalemnte a cada ano.

- Edições do Java

    Java SE (Java Standard Edition): para programação desktop

    Java EE (Java Enterprise Edition): para programação web

    Java ME (Java Micro Edition): para programação de dispositivos embarcados

    JavaFX: para programação de multimidia

- Java Virtual Machine (JVM)

	Java Virtual Machine ou Máquina Virtual Java é um programa que carrega e executa os aplicativos Java.

- Kits Java

	Java Runtime Environment (JRE): programa a ser instalado para execução de programas Java, possui a máquina virtual Java (JVM).

	Java Development Kit (JDK): programa a ser instalado para desenvolvimento e execução de programas Java (JVM), possui a máquina virtual Java, as APIs (bibliotecas) de desenvolvimento e o compilador Java.

	Estes kits são disponibilizados para diversos sistemas operacionais, permitindo assim a criação e execução de aplicativos Java nestes ambientes.

- Estrutura de uma aplicação Java

	Uma aplicação Java basicamente é composta por classes.

	O agrupamento lógico de classes relacionadas se chama "package".

	O agrupamento lógico de "package's" relacionadas se chama "module".

	O agrupamento lógico de "module's" relacionadas se chama "application".

- Operadores aritméticos

	+	adição
	-	subtração
	*	multiplicação
	/	divisão
	%	resto da divisão

	Precedência dos operadores

	* / %
	+ -

- Agrupamento de expressões

	Utilizamos parênteses ( ) para agrupamento de expressões aritméticas.

- Variáveis

	Em programação, uma variável é uma porção de memória (RAM) utilizada para armazenar dados durante a execução dos programas.

	Declaração sem atribuir valor:

	<tipo> <nome>;

	Declaração atribuindo valor:

	<tipo> <nome> = <valor inicial>;

	Regras para nomes de variáveis:

	Não pode começar com dígito
	Não pode ter espaço em branco
	Não usar acentos
	Use nomes que tenham significado / relação com o que a variável representa
	Use o padrão "CamelCase", em específico o "lowerCamelCase" (de letra inicial minúscula)

- Inicialização de variaveis
	
	Por padrão as variaveis de métodos não são inicializadas, devem ser inicializadas manualmente antes do uso caso contrario será apresentado erro.

	Por padrão as variaveis de classes (atributos)  são inicializadas automaticamente com valores padrão conforme tabela abaixo.

	Tipo		Valor padrão

	byte		0
	short		0
	int			0
	long		0L
	float		0.0f
	double		0.0d
	char		'\u0000'
	String 		null
	boolean		false

- Escopo

	O escopo é a vida de uma variável em Java, tratando-se dos locais nos quais ela pode ser acessada. Em Java, o escopo de variáveis vai de acordo com o bloco onde ela foi declarada. A variável é criada no primeiro acesso a ela e destruída após o interpretador sair do bloco de execução ao qual ela pertence.

	Um bloco é determinado por chaves { } .

- Convenções de nomes em Java

	Lower Camel Case ("lastName" por exemplo):

	pacotes
	atributos
	métodos
	variáveis e parâmetros

	Pascal Case ("UserAccount" por exemplo):

	classes

- Tipos primitivos em Java

	São variáveis básicas da linguagem Java, elas guardam o valor dentro delas mesmo.

	Descrição 								Tipo 		Tamanho 	Valores 										Valor padrão

	tipos numéricos inteiros				byte 		8 bits 		-128 a 127 										0
	tipos numéricos inteiros				short 		16 bits 	-32768 a 32767 									0
	tipos numéricos inteiros				int 		32 bits 	-2147483648 a 2147483647 						0
	tipos numéricos inteiros				long 		64 bits 	-9223372036854770000 a 9223372036854770000 		0L
	tipos numéricos com ponto flutuante		float 		32 bits 	-1,4024E-37 a 3,4028E+38 						0.0f
	tipos numéricos com ponto flutuante		double 		64 bits 	-4,94E-307 a 1,79E+308 							0.0
	um caractere Unicode 					char 		16 bits 	'\u0000' a '\uFFFF' 							'\u0000'
	valor verdade 							boolean 	1 bit 		false, true 									false

- Escrevendo na tela

	Sem quebra de linha:

	System.out.print(<texto ou variável a ser exibido na tela>);

	Com quebra de linha:

	System.out.println(<texto ou variável a ser exibido na tela>);

	Com formatação:

	System.out.printf(<marcadores>, <variáveis>);

	Marcadores:

	Especificador 	Formato

	%s 				String
	%d 				Tipos inteiros
	%f 				Tipos de ponto flutuante
	%b 				Booleanos
	%c 				Caracteres
	%n 				Quebra de linha

	Controle de casas decimais para tipo de ponto flutuante:

	Utilizar "%.<quantidade de casas desejadas>f"

- Concatenação de texto

	Para "print" e "println" utilizar o sinal de "+" para concatenação do texto.

	Para "printf" não existe concatenação de texto pois a estrutura é diferente, a frase ja é formatada antes.

- Separador decimal

	Por padrão "print" e "println" utilizam o sistema americano que determina o "." como separador decimal.

	Por padrão "printf" utiliza a localização do sistema operacional para determinar o separador decimal, no caso do Brasil a ",".

	Caso queria alterar para o sistema americano de separador decimal com "." precisamos importar a classe "Locale" no início do programa:

	import java.util.Locale;

	E em seguida, dentro do método, declarar a configuração:

	Locale.setDefault(Locale.US);

- Comentários

	Comentários em programas Java são códigos dentro dos programas que não serão executados mas server para dar informações relativas ao código.

	Exemplo:

	// Comentario de uma linha

	/*
	 * Comentário 
	 * de
	 * bloco
	 */

	/**
	 * Comentário 
	 * de
	 * bloco JavaDoc
	 */

- Casting

	Conversão entre tipos de variáveis, temos dois tipos, implicita (automatica) e explicita (forçada).

	É necessário quando o compilador não é capaz de "adivinhar" que o resultado de uma expressão deve ser de outro tipo.

	Uso:

	A conversão implicita (automatica) não precisa de intervenção alguma.

	A conversão explicita (forçada) é feita colocando o tipo desejado em frente ao valor a ser convertido "(<tipo desejado>) <valor a ser convertido>".

	Tabela de conversão implicita e explicita:

	De / Para	byte 	  short 	 	char 	 	int 	 		long 	 		float 	 		double

	byte 		N/A 	  implicito 	char 		implicito		implicito		implicito		implicito
	short 		byte 	  N/A 			char 		implicito		implicito		implicito		implicito
	char 		byte 	  short		 	N/A 		implicito		implicito		implicito		implicito
	int 		byte 	  short		 	char 		N/A 			implicito		implicito		implicito
	long 		byte 	  short		 	char 		int 			N/A 			implicito		implicito
	float 		byte 	  short		 	char 		int 			long 			N/A 			implicito
	double 		byte 	  short		 	char 		int 			long 			float 			N/A

	O tipo de dado boolean é o único tipo primitivo que não suporta casting.

- Entrada de dados

	Importar a classe "Scanner" no inicio do programa:

	import java.util.Scanner;

	Declarar um objeto Scanner padrão:

	Scanner sc = new Scanner(System.in);

	Para entrada de dados utilziamos os métodos especificos para cada tipo:

	sc.next(); 						Entrada de valor texto sem espaço
	sc.nextLine(); 					Entrada de valor texto de diversas palavras (com espaço)
	sc.next().charAt(0); 			Entrada de valor char
	sc.nextLong(); 					Entrada de valor long
	sc.nextInt(); 					Entrada de valor int
	sc.nextByte(); 					Entrada de valor byte
	sc.nextShort(); 				Entrada de valor short
	sc.nextDouble(); 				Entrada de valor double
	sc.nextFloat(); 				Entrada de valor float
	sc.nextBoolean(); 				Entrada de valor boolean

	Ao término do uso do objeto Scanner o mesmo deve ser fechado:

	sc.close();

	Atenção!

	Quando você usa um comando de leitura diferente do "nextLine()" e dá alguma quebra de linha, essa quebra de linha fica "pendente" na entrada padrão.
	
	Se você então fizer um "nextLine()" aquela quebra de linha pendente será absorvida pelo "nextLine()" e o programa apresentara erro ou algum comportamento estranho.

	Solução: Faça um "nextLine()" extra antes de fazer o "nextLine()" de seu interesse.

- Três operações básicas de programação

	Entrada de dados: normalmente feita pelo teclado ou mouse

	Processamento de dados: feita pelo processador

	Saída de dados: normalmente feito pelo monitor

- Funções matemáticas

	Existem algumas funções já pré-definidas em Java, elas fazem parte da classe "Math", seguem exemplos:

	Exemplo 								Significado

	Math.sqrt(<valor x>); 					resultado da raiz quadrada de x
	Math.pow(<valor x>, <valor y>); 		resultado de x elevado a y
	Math.abs(<valor x>); 					resultado da valor absoluto de x

	A classe Math também ja fornece o valor de PI como uma variável:

	Math.PI

	Existem diversas outras funções já prontas, basta verificar a documentação da classe "java.lang.Math".

- Operadores de atribuição acumulativa

	Usados como forma abreviada de escrever que uma variável recebe o valor dela em uma operação onde ela esta envolvida.

	Operador 		Exemplo de uso

	+= 				a = a + b;
	-= 				a = a - b;
	*= 				a = a * b;
	/= 				a = a / b;
	%= 				a = a % b;

- Operadores comparativos

	Operador 		Significado
	
	>  				maior
	<  				menor
	>= 				maior ou igual
	<= 				menor ou igual
	== 				igual
	!= 				diferente

- Operadores lógicos

	Operador 		Significado

	&& 				E
	|| 				OU
	! 				NÃO

- Estruturas de seleção

	if (simples)

		if (<condição>) {
			<comandos a serem executados caso a condição acima seja verdadeira>
		}

	if...else (composta)

		if (<condição>) {
			<comandos a serem executados caso a condição acima seja verdadeira>
		} else {
			<comandos a serem executados caso a condição acima seja falsa>
		}

	if...else else...if (aninhada)

		if (<condição>) {
			<comandos a serem executados caso a condição acima seja verdadeira>
		} else if (<condição>) {
			<comandos a serem executados caso a condição cima seja verdadeira>
		} else if (<condição>) {
			<comandos a serem executados caso a condição cima seja verdadeira>
		}
		...
		} else {
			<comandos a serem executados caso todas as condições acima sejam falsas>
		}

	switch (seleção específica)

		switch (<variavel>) {
			case <valor>:
				<ações a executar caso o valor seja igual a variável>;
				break;
			case <valor>:
				<ações a executar caso o valor seja igual a variável>;
				break;
			...
			default:
				<ações a executar caso nenhuma alternativa anterior seja válida>;
		}

	operador ternário ? (seleção dupla)

		<variavel que irá receber o valor> = (<condição>) ? <valor se verdadeiro> : <valor se falso>;

- Estruturas de repetição

	while (usada quando não se sabe quantas vezes vai repetir, teste no inicio, pode nunca ser executada)

		<declaração da variavel de controle>;

		while (<teste da variável de controle>) {
			<código  a ser executado caso a condição seja satisfeita>
			...
			<alteração do valor da variável de controle se necessário>
		}

	for (usada quando se sabe a quantidade de vezes a ser executada, sempre é executada)

		for (<declaração da variável de controle>; <teste da variavel de controle>; <incremento ou decremento da variavel de controle>) {
			<código a ser executado quando a repetição for executada>
		}

	do while (usada quando não se sabe quantas vezes vai repetir, teste no final, é executada ao menos uma vez)

		<declaração da variavel de controle>;

		do {
			<código  a ser executado caso a condição seja satisfeita>
			...
			<alteração do valor da variável de controle se necessário>
		} while (<teste da variável de controle>);

- Operadores bitwise (bit a bit)

	Operador 			Significado

	& 					Operação "E" bit a bit
	| 					Operação "OU" bit a bit
	^ 					Operação "OU-exclusivo" bit a bit

- Funções para String

	toLowerCase() - passa a String para lowercase
	toUpperCase() - passa a String para uppercase
	trim() - corta os espaços no começo e no final da String
	substring(<posição inicial>) - cria uma nova String a partir de uma posição ate o final da String
	substring(<posição inicial>, <posição final>) - cria uma nova String a partir de uma posição ate uma posição final
	replace(<char>, <char>) - troca um char da String
	replace(<string>, <string>) - troca uma parte da String
	indexOf(<string>) - retorna a primeira posição onde a String foi encontrada
	lastIndexOf(<string>) - retorna a última posição onde a String foi encontrada
	split(<separador>) - cria um vetor com as substrings criadas pelo separador

- Classes

	É um tipo estruturado que pode conter:

	Atributos
	Métodos

	A classe também pode prover muitos outros recursos, tais como:

	Construtores
	Sobrecarga
	Encapsulamento
	Herança
	Polimorfismo

	Exemplos de classes:

	Entidades: Produto, Cliente, Triangulo
	Serviços: ProdutoService, ClienteService, EmailService, StorageService
	Controladores: ProdutoController, ClienteController
	Utilitários: Calculadora, Compactador
	Outros (views, repositórios, gerenciadores, etc.)

	Caracterisiticas:

	Toda classe possui um nome
	Possue visibilidade (exemplo: public, private, protected ou default)
	Podem possuir membros (exemplo: atributos, métodos)

- Classe principal (Program)

	É a classe "entry-point" da aplicação, a primeira a ser iniciada ao executar um programa em Java.

	Para isso ela possui o método "main".

- Estrutura básica de uma classe

	<pacote que a classe faz parte>;

	<importação de pacotes necessários>;

	<declaração da classe> {
		
		<declaração de atributos>...

		<declaração de métodos>...

	}

	Exemplo:

	package entities;

	import java.util.Locale;

	public class Triangle {

		public double a;
		public double b;
		public double c;
		
		public double area() {
			
			double p = (a + b + c) / 2.0;
			double r = Math.sqrt(p * (p - a) * (p - b) * (p - c));
			
			return r;
		}
		
	}

- Pacotes (package)

	Um pacote ou "package" na tecnologia Java nada mais é do que um conjunto de classes localizadas na mesma estrutura hierárquica de diretórios.

	Usualmente, são colocadas em um package classes relacionadas, construídas com um propósito comum para promover a reutilização de código.

	Deve ser declarado a primeira linha da classe.

	Exemplo:

		package <nome do pacote>;

		package entities;

	Sugestão de pacotes

		application
		model
			entities
			enums
			exceptions
			services

- Declaração import

	A instrução "import" da linguagem Java tem como objetivo disponibilizar em uma classe, de um determinado pacote, o acesso a demais classes que estejam em pacotes diferentes.

	Para isso basta inserir a declaração "import" após a declaração "package" da classe, exemplo:

	import <caminho fqdn da classe>;

	import java.util.Locale;

- Modificadores de acesso

	Temos quatro modificadores de acesso básicos da linguagem Java: public, private, protected e default.

	Eles servem para tornar componentes da sua aplicação mais ou menos acessíveis por outras partes do seu programa.

	Resumo dos modificadores:

		public: o membro é acessado por todas classes (ao menos que ele resida em um módulo diferente que não exporte o pacote onde ele está)

		private: o membro só pode ser acessado na própria classe

		protected: o membro só pode ser acessado no mesmo pacote, bem como em subclasses de pacotes diferentes

		(default): o membro só pode ser acessado nas classes do mesmo pacote		

	Detalhes dos modificadores:

	"public"

	Não impõe restrições de acesso ao item, deixando-o visível para todo e qualquer classe. Esse modificador pode ser aplicado sobre todos os itens:

	    Classes
	    Classes internas
	    Interfaces
	    Interfaces internas
	    Annotations
	    Annotations internas
	    Enum
	    Enums internos
	    Métodos
	    Atributos

	"private"

	O modificador que mais restringe a visibilidade do item marcado deixando-o visível somente para a classe que o definiu. Em uma herança a restrição de acesso atinge também as classes filhas, impedindo-as de acessarem o item sob o modificador private. Esse modificador pode ser aplicado sobre os seguintes itens:

	    Classes internas
	    Interfaces internas
	    Annotations internas
	    Enums internos
	    Métodos
	    Atributos

	"protected"

	Restringe o acesso ao item sob o modificador deixando-o visível somente para as classes filhas da classe que possui o item e para classes que se encontram sob o mesmo pacote da classe que possui o item. Esse modificador pode ser aplicado sobre os itens:

	    Classes internas
	    Interfaces internas
	    Annotations internas
	    Enums internos
	    Métodos
	    Atributos

	"default":

	Restringe o acesso ao item sob o modificador deixando-o visível somente para as classes que se encontram sob o mesmo pacote da classe que possui o item. Em uma herança a restrição de acesso atinge também as classes filhas que não estejam no mesmo pacote, impedindo-as de acessarem o item sob o modificador default.

	Para esse modificador não há uma palavra chave definida para o uso aqui. O modificador aqui é a omissão dos outros modificadores. Esse modificador pode ser aplicado sobre os seguintes itens:

	    Classes
	    Classes internas
	    Interfaces internas
	    Annotations  internas
	    Enums internos
	    Métodos
	    Atributos

    Visibilidade de um item com o modificador de acesso

	Para testar a visibilidade de um item com o seu modificador de acesso há cinco cenários diferentes:

    A partir da mesma classe
    Qualquer classe no mesmo package
    Qualquer classe filha no mesmo package
    Qualquer classe filha em package diferente
    Qualquer classe em package diferente

    Para isso utilizamos a tabela abaixo:

	Visibilidade 									public 		protected 		default 	private

    A partir da mesma classe 						OK			OK 				OK 			OK
    Qualquer classe no mesmo package 				OK			OK 				OK 			Não
    Qualquer classe filha no mesmo package 			OK			OK 				OK 			Não
    Qualquer classe filha em package diferente 		OK			OK 				Não 		Não
    Qualquer classe em package diferente 			OK			Não 			Não 		Não

- Atributos

	Os atributos são as propriedades de uma classe, também são conhecidos como variáveis ou campos. Essas propriedades definem o estado de um objeto, fazendo com que esses valores possam sofrer alterações.

	Eles são declarados como variaveis comuns porpém dentro da classe.

	Exemplo:

	int idade;

- Referência "this"

	É uma referencia para o proprio objeto.

	Usos comuns:

	Diferenciar atributos de variáveis locais
	Passar o próprio objeto como argumento na chamada de um método ou construtor

	Por exemplo, caso algum atributo tenha o mesmo nome de um parâmetro de método (normalmente no método construtor) podemos referenciar o atributo do objeto com a palavra "this" antes do atributo ao utilizar o mesmo.

	Exemplo:

	this.<nome do atributo>

	this.quantidade = quantidade;

- Métodos

	Representam um processamento que possui um significado.

	As principais vantagens: modularização, delegação e reaproveitamento de código.

	Dados de entrada e saída:

	Funções podem receber dados de entrada (parâmetros)
	Funções podem ou não retornar uma saída

	Estrutura:

	<modificador de acesso> <propriedade de instanciação se necessário> <tipo de retorno> <nome do método>(<ipo do parâmetro> <nome do parâmetro>, ...)
		<código do método>
		<retorno do método caso exista>
	}

	Exemplo:

	public static int max(int x, int y, int z) {

		int maxNumber;

		if (x > y && x > z) {
			maxNumber = x;
		} else if (y > x && y > z) {
			maxNumber = y;
		} else {
			maxNumber = z;
		}

		return maxNumber;
	}

- Método "main"

	É o primeiro método executado em um programa Java, considerado como o "entry-point" da aplicação.

	Normalmente ele está na classe "Program".

	Ele deve ser declarado sempre da mesma forma:

	public static void main(String[] args) {
		<código do método>
	}

- Objeto

	Uma classe é como se fosse uma planta de uma casa, um  desenho, um projeto de algo. Não podemos utilizar uma planta de uma casa para morar, precisamos contruir a casa.

	Desta forma um objeto é como se fosse a casa construida a partir da planta.

	A classe tem a descrição do que o objeto possui e faz, mas é somente um projeto, para utilizarmos a classe criamos objetos baseados nela.

- Declaração e instanciação de um objeto

	Para criarmos um objeto temos dois passos, a declaração e a instanciação.

	A declaração de um objeto é feito igual a uma variavel comum.

	Exemplo:

	<nome da classe> <nome do objeto>;

	Triangulo t;

	Ela cria na memória (stack) uma variável com conteúdo vazio.

	Instanciar é o ato de criar o objeto na memória (heap)e inserir seu endereço dentro da variavel criada anteriormente.

	Exemplo:

	<nome do objeto> = new <nome da classe>(<parametros se necessario):

	t = new Triangulo(2.00, 3.00, 5.00);

	Uma variavel do tipo comum (primitiva) guarda dentro dela o valor propriamente dito, ja uma variavel do tipo objeto guarda um valor de endereço de memoria que redireciona a variavel (como um link ou ponteiro) ao local onde os dados efetivamente estao.

- Classe "Object"

	Toda classe em Java é uma subclasse da classe "Object".

	Object possui os seguintes métodos:

	getClass()- retorna o tipo do objeto
	equals() - compara se o objeto é igual a outro
	hashCode() - retorna um código hash do objeto
	toString() - converte o objeto para string

- Método "toString()"

	Ao tentar imprimir um objeto diretamente no console recebemos como resultado o nome do pacote e classe ao qual o objeto pertence, assim como seu endereço de memória.

	Exemplo:

	entities.Product@6108b2d7

	Esta informação não tem muita utilidade.

	Caso seja necessario retornar informações relativas a atributos e métodos do objeto como uma String devemos utilizar o método "toString()".

	Este método existe na classe pai "Object" e é herdada por todos os objetos em Java, desta forma a implementação feita em "Object" retorna o exemplo citado acima.

	Podemos reescrever este método em nossas classes, retornando dentro dele como gostariamos que o objeto fosse impresso em um console.

	Para isso utilizamos a estrutura abaixo:

	@Override
	public String toString() {
		return <dados a serem exibidos do objeto>;
	}

	Exemplo:

	@Override
	public String toString() {
		return name + ", " + quantity;
	}

	O "@Override" serve para mostrar que este método esta reescrevendo um método ja definido em uma classe pai.

- Método "String.format()"

	Utilizado para aplicar formatação similar ao "printf" em uma String.

	Exemplo:

	return name + ", " + String.format("%.2f", quantity);

	Normalmente é utilizada junto ao método "toString()".

- Membros de instancia

	Uma classe possui membros, esses membros são os atributos e os métodos.

	Ao criar e instanciar um objeto cada um irá possuir uma cópia (instancia) dos membros, estes membros são chamados de "membro de intancia" ou "membros de objeto".

	Cada objeto conhece somente os seus membros, membros de outros objetos (mesmo sendo da mesma classe) não são conhecidos.

- Membros estaticos

	Também chamados membros de classe em oposição a membros de instância.

	São membros que fazem sentido independentemente de objetos. Não precisam de objeto para serem chamados. São chamados a partir do próprio nome da classe.

	Exemplo:

	Math.sqrt();

	Não precisamos instanciar um objeto da classe Math para utiliza-la, basta chamamos seus métodos de forma direta.

	Aplicações comuns:

	Classes utilitárias
	Declaração de constantes

	Uma classe que possui somente membros estáticos, pode ser uma classe estática também. Esta classe não poderá ser instanciada.

	Para declarar um mebro estatico basta inserir a palavra "static" em sua declaração.

	Exemplo:

	Atributos:

	public static <tipo da variavel> <nome da variável> = <valor da variável>;

	public static double pi = 3.14159;
	
	Métodos:

	<modificador de acesso> static <tipo de retorno> <nome do método>(<ipo do parâmetro> <nome do parâmetro>, ...)
		<código do método>
		<retorno do método caso exista>
	}

	public static double volume(double radius) {
		return (4.0 * PI * Math.pow(radius, 3)) / 3;
	}

- Constantes

	Uma constante é um tipo especial de variável cujo valor, uma vez definido, não pode mais ser alterado durante a execução do programa.

	Declaramos uma constante em Java usando a palavra-chave final.
	
	Exemplo:

	public static final double PI = 3.14159;

	Declarar sempre uma constante usando apenas letras maiúsculas, e em caso de palavras compostas, separá-las com um underline (_).

- Construtores

	É uma operação especial da classe, que executa no momento da instanciação do objeto.

	Usos comuns:

	Iniciar valores dos atributos
	Permitir ou obrigar que o objeto receba dados / dependências no momento de sua instanciação (injeção de dependência)

	Se um construtor customizado não for especificado, a classe disponibiliza o construtor vazio (default) que instacia o objeto com valores padrão de cada tipo.

	Valores padrão:

	Descrição 								Valor padrão

	tipos numéricos inteiros				0
	tipos numéricos com ponto flutuante		0.0
	tipo char 			 					'\u0000' (null)
	tipo boolean 							false
	tipo object 							null

	Também é possível especificar mais de um construtor na mesma classe (sobrecarga).

	Declaração:

	Construtor vazio (default)

		Basta não declarar nenhum método construtor na classe e instaciar a mesma passando sem passar nenhum argumento entre os parenteses, por exemplo:

		Product p = new Product();

		Desta forma os atributos do objeto serão inicializados com o valor padrão para cada tipo.

		Atenção, o construtor vazio so funciona se não existir nenhu outro construtor dentro da classe, caso exista algum construtor o mesmo deve ser utilziado e instanciar um objeto sem parametros resultara em erro.

	Contrutor padrão

		Para criarmos um contrutor padrão devemos criar um método dentro da classe que será instanciada, o método possuirá o nome da propria classe, seguindo a estrutura abaixo:

		<public <nome da classe>(<parametros>) {
			this.Nome do atributo interno da classe> = <parametro>...
		}

		public Product(String name, double price, int quantity) {
			this.name = name;
			this.price = price;
			this.quantity = quantity;
		}

		Caso algum atributo necessite ser iniciado com valor especifico podemos colocar dentro do construtor tambem, por exemplo:

		public Product(String name, double price, int quantity) {
			this.name = name;
			this.price = price;
			this.quantity = 0;
		}

- Sobrecarga de métodos

	É um recurso que uma classe possui de oferecer mais de uma método com o mesmo nome, porém com diferentes listas de parâmetros.

	Pode ser utilizado em métodos comuns e em construtores.

	Segue exemplo com construtores:

	// Construtor com valores default
	public Product() {
	}
	
	// Construtor recebendo os 3 parametros
	public Product(String name, double price, int quantity) {
		this.name = name;
		this.price = price;
		this.quantity = quantity;
	}
	
	// Construtor recebendo 2 parametros e um com valor default
	public Product(String name, double price) {
		this.name = name;
		this.price = price;
	}

- Encapsulamento

	É um princípio que consiste em esconder detalhes de implementação de uma classe, expondo apenas operações seguras e que mantenham os objetos em um estado consistente.

	O objeto deve sempre estar em um estado consistente, e a própria classe deve garantir isso.

	Regra geral básica:

	Um objeto NÃO deve expor nenhum atributo (atributos devem ter modificador de acesso private)
	Os atributos devem ser acessados por meio de métodos get e set

	Padrão para implementação de métodos getters e setters

	O método get é utilizado para recuperar o valor do atributo, exemplo de declaração:

	public <tipo de retorno> get<nome do atributo>() {
		return <atributo>;
	}

	public String getName() {
		return name;
	}

	O método set é utilizado para configurar o valor do atributo, exemplo de declaração:

	public void set<nome do atributo>(<tipo do parametro> <parametro>) {
		this.<nome do atributo> = <parametro>;
	}

	public void setName(String name) {
		this.name = name;
	}

- Área de memória Heap e Stack

	O sistema operacional ao carregar um programa na memória disponibiliza ao programa um espaço de endereçamento, esse espaço é a memória disponível para aquele programa.

	O Heap, ou área de alocação dinâmica, é um espaço reservado para variáveis e dados criados durante a execução do programa. Vamos dizer que o Heap é a memória global do programa.

	O Stack é uma área da memória que aloca dados, variáveis ou ponteiros quando uma função é chamada e desalocada quando a função termina. Podemos dizer então que representa a memória local àquela função. 

- Variáveis tipos valor (primitivos) vs tipos referência (classes)

	Variáveis tipos valor (primitivos) são criados na área Stack, são como se fossem caixas que guardam exatamente o valor que for atribuido a variável, por exemplo, se atribuirmos o valor 1 a variável teremos o valor 1 dentro da caixa.

	Variáveis Tipos referência (classes) são criados inicialmente na área Stack, são como se fossem caixas assim como os tipos primitivos, mas diferente deles as caixas não guardam os valores atribuidos a variável e sim um valor de memória que aponta para um local na área Heap. Neste local da area Heap teremos uma caixa que irá guardar os valores do objeto. Funcionando como um ponteiro.

	Tabela comparativa:

	Classe																					Tipo Primitivo

	Vantagem: usufrui de todos recursos OO 													Vantagem: é mais simples e mais performático
	Variáveis são ponteiros 																Variáveis são caixas
	Objetos precisam ser instanciados ou apontar para um objeto já existente. 				Não instancia. Uma vez declarados, estão prontos para uso.
	Aceita valor null 																		Não aceita valor null
	Y = X; "Y passa a apontar para onde X aponta" 											Y = X; "Y recebe uma cópia de X"
	Objetos instanciados no heap 															Variaveis são criadas no stack
	Objetos não utilizados são desalocados em um momento próximo pelo garbage collector 	Variaveis são desalocados imediatamente quando seu escopo de execução é finalizado

- Garbage collector

	É um processo que automatiza o gerenciamento de memória de um programa em execução.

	O garbage collector monitora os objetos alocados dinamicamente pelo programa (no heap), desalocando aqueles que não estão mais sendo utilizados (não possuem mais ponteiros apontando para eles).

- Desalocação por garbage collector e por escopo

	A desalocação por garbage collector é feita automaticamente, sem intervenção do usuário, de tempos em tempos. Funciona para tipos referencias (classes).

	A desalocação por escopo é feita assim que o escopo onde a variável foi criada é encerrado, pode ser um método, uma estrutura de repetição ou de seleção. Funciona para tipos valor (primitivos).

- Vetor (array)

	Vetor (array) é o nome dado a arranjos unidimensionais.

	Vetor é uma estrutura de dados:

		Homogênea (dados do mesmo tipo)
		Ordenada (elementos acessados por meio de posições)
		Alocada de uma vez só, em um bloco contíguo de memória

	Vantagens:

		Acesso imediato aos elementos pela sua posição

	Desvantagens:

		Tamanho fixo
		Dificuldade para se realizar inserções e deleções

	Declaração:

		<tipo do vetor>[] <nome da variavel>;

		double[] number;

	Instanciação:

		<nome da variavel> = new <tipo do vetor>[<tamanho do vetor>];

		number = new double[3];

	Declaração e instanciação na mesma linha:

		<tipo do vetor>[] <nome da variavel> = new <tipo do vetor>[<tamanho do vetor>];

		double[] number = new double[3];

	Atributos de um vetor:

		length - mostra o tamanho do vetor

- Matrizes

	Matriz é o nome dado a arranjos bidimensionais.

	Matriz é uma estrutura de dados:

		Homogênea (dados do mesmo tipo)
		Ordenada (elementos acessados por meio de posições)
		Alocada de uma vez só, em um bloco contíguo de memória

	Vantagens:

		Acesso imediato aos elementos pela sua posição

	Desvantagens:

		Tamanho fixo
		Dificuldade para se realizar inserções e deleções

	Declaração:

		<tipo da matriz>[][] <nome da variavel>;

		double[][] number;

	Instanciação:

		<nome da variavel> = new <tipo da matriz>[<quantidade de linhas>][<quantidade de colunas>];

		number = new double[2][3];

	Declaração e instanciação na mesma linha:

		<tipo da matriz>[][] <nome da variavel> = new <tipo da matriz>[<quantidade de linhas>][<quantidade de colunas>];

		double[][] number = new double[2][3];

	Atributos de um vetor:

		length - mostra o tamanho de linhas ou colunas da matriz


- Laço "for each"

	Sintaxe opcional e simplificada para percorrer coleções.

	Ela serve somente para exibição, não serve para modificar os valores dos itens das coleções.

	Sintaxe:

	for (<tipo da coleção> <variavel interna do laço> : <variavel da coleção>) {
		<comandos a serem executados>
	}

	Exemplo:

	String[] vect = new String[] {"Bolacha", "Minhoca", "Gabriel"};
	
	for (String nome : vect) {
		System.out.println(nome);
	}

- Boxing, unboxing e wrapper classes

	Boxing

		É o processo de conversão de um objeto tipo valor (primitivo) para um objeto tipo objeto compatível, exemplo:

		int x = 20;
		Object obj = x;

	Unboxing:

		É o processo de conversão de um objeto tipo objeto para um objeto tipo valor (primitivo), exemplo:

		int x = 20;
		Object obj = x;
		int y = (int) obj;

		O processo de Boxing é feito de forma implicita, já o processo de Unboxing é feito de forma explicita (com casting).

	Wrapper classes

		Para facilitar o processo de Boxing e Unboxing foram criadas as wrapper classes, elas são classes equivalentes aos tipos primitivos, segue tabela:

		Tipo primitivo 			Wrapper classes

		byte					Byte
		short					Short
		int						Integer
		long					Long
		float					Float
		double					Double
		char					Character
		boolean					Boolean

		Uso comum: campos de entidades em sistemas de informação, pois tipos referência (classes) aceitam valor null e usufruem dos recursos OO.

		Atributos de classes devem ser declarados como Wrapper classes para boa prática, exemplo:

		public class Product {
			private String name;
			private Double price;
			private Integer quantity;
			(...)

		A wrappers classes podem ser utilizadas como se fosse um tipo primitivo normalmente, inclusive em calculos, exemplo:

		Integer x = 10;
		int y = x * 2;

- Listas

	Lista é uma estrutura de dados:

		Homogênea (dados do mesmo tipo)
		Ordenada (elementos acessados por meio de posições)
		Inicia vazia, e seus elementos são alocados sob demanda
		Cada elemento ocupa um "nó" (ou nodo) da lista
		Não aceita tipos primitivos, somente classes

	Seu tipo é o "List".

	Podemos declarar um tipo como "List" porem não podemos instanciar devido a ser uma interface, a instanciação deve ser feita em uma de suas implementações.

	Seguem algumas classes que implementam "List":

		AbstractList, AbstractSequentialList, ArrayList, AttributeList, CopyOnWriteArrayList, FilteredList, LinkedList, ListBinding, ListExpression, ListProperty, ListPropertyBase, ModifiableObservableListBase, ObservableListBase, ReadOnlyListProperty, ReadOnlyListPropertyBase, ReadOnlyListWrapper, RoleList, RoleUnresolvedList, SimpleListProperty, SortedList, Stack, TransformationList, Vector

	Vantagens:

		Tamanho variável
		Facilidade para se realizar inserções e deleções

	Desvantagens:

		Acesso sequencial aos elementos

	Declaração:

		List<tipo a ser guardado> <nome da lista> = new <implementação da lista><>();

		List<String> list = new ArrayList<>();

	Métodos:

		size() - mostra o tamanho da lista
		add(<elemento>) - adicionar elemento na ultima posição
		add(<posição>, <elemento>) - adicionar elemento na posição desejada
		remove(<elemento ou posição>) - remover elemento da lista
		get(<posição>) - obter o elemento da posição
		indexOf(<elemento>) - busca o primeiro elemento na lista com o valor desejado
		lastIndexOf(<elemento>) - busca o ultimo elemento na lista com o valor desejado

- Datas (versão Java v8 ou mais atual)

	Boa prática geral "armazene horário UTC, mostre horário local"

	Conceitos importantes:

	Data-hora local:

		ano-mês-dia-hora sem fuso horário
		hora opcional

	Data-hora global:

		ano-mês-dia-hora com fuso horário

	Duração:

		tempo decorrido entre duas data-horas

	Quando usar?

	Data-hora local:

		Quando o momento exato não interessa a pessoas de outro fuso horário. Uso comum: sistemas de região única.

		Exemplos:

		Data de nascimento: "15/06/2001"
		Data-hora da venda: "13/08/2022 às 15:32"

	Data-hora global:

		Quando o momento exato interessa a pessoas de outro fuso horário. Uso comum: sistemas multi-região, web.

		Exemplos:

		Quando será o sorteio? "21/08/2022 às 20h (horário de São Paulo)"
		Quando o comentário foi postado? "há 17 minutos (horário de São Paulo)"
		Quando foi realizada a venda? "13/08/2022 às 15:32 (horário de São Paulo)"
		Início e fim do evento? "21/08/2022 às 14h até 16h (horário de São Paulo)"

	Timezone (fuso horário)

		GMT - Greenwich Mean Time:

			Horário de Londres
			Horário do padrão UTC - Coordinated Universal Time
			Também chamado de "Z" time, ou Zulu time

		Outros fuso horários são relativos ao GMT/UTC:

			São Paulo: GMT-3
			Manaus: GMT-4
			Portugal: GMT+1

		Muitas linguagens/tecnologias usam nomes para as timezones:

			"US/Pacific"
			"America/Sao_Paulo"

		Padrão ISO 8601 para gravação de hora em formato texto

	Data-hora local:

		<ano>-<mês>-<dia>T<hora>:<minuto>:<segundo>.<milesimos>

		Exemplos:

		2022-07-21
		2022-07-21T14:52
		2022-07-22T14:52:09
		2022-07-22T14:52:09.4073

	Data-hora global:

		<ano>-<mês>-<dia>T<hora>:<minuto>:<segundo>.<milesimos>Z

		Ou

		<ano>-<mês>-<dia>T<hora>:<minuto>:<segundo>.<milesimos>-<diferença de fuso horario>

		Exemplos:

		2022-07-23T14:52:09Z
		2022-07-23T14:52:09.254935Z
		2022-07-23T14:52:09-03:00

	Operações possiveis com data-hora

		Instanciação:

			(agora) > Data-hora
			Texto ISO 8601 > Data-hora
			Texto formato customizado > Data-hora
			dia, mês, ano, [horário] > Data-hora local

		Formatação:

			Data-hora > Texto ISO 8601
			Data-hora > Texto formato customizado

		Converter data-hora global para local:

			Data-hora global, timezone (sistema local) > Data-hora local

		Obter dados de uma data-hora local:

			Data-hora local > dia, mês, ano, horário

		Cálculos com data-hora:

			Data-hora +/- tempo > Data-hora
			Data-hora 1, Data-hora 2 > Duração

	Principais tipos

		Data-hora local:

			LocalDate
			LocalDateTime

		Data-hora global:

			Instant

		Duração:

			Duration

		Outros:

			ZoneId
			ChronoUnit

	Declaração

		Objetos LocalDate precisam importar  a classe "java.time.LocalDate".

		Objetos LocalDateTime precisam importar  a classe "java.time.LocalDateTime".

		Objetos Instant precisam importar  a classe "java.time.Instant".

		Data-hora local:

			LocalDate (somente data atual)

				LocalDate <nome da variável> = new LocalDate.now();

				Exemplo:

				LocalDate date = new LocalDate.now();

			LocalDate (somente data manual)

				LocalDate <nome da variável> = new LocalDate.of(<data no formato ano, mes, dia>);

				Exemplo:

				LocalDate date = new LocalDate.of(2022, 07, 26);

			LocalDateTime (data com horário atual)

				LocalDateTime <nome da variável> = new LocalDateTime.now();

				Exemplo:

				LocalDateTime date = new LocalDateTime.now();

			LocalDateTime (data com horário manual)

				LocalDateTime <nome da variável> = new LocalDateTime.of(<data no formato ano, mes, dia, hora, minuto>);

				Exemplo:

				LocalDateTime date = new LocalDateTime.of(2022, 07, 26, 1, 30);

		Data-hora global:

			Instant (data com horário atual)

				Instant <nome da variavel> = Instant.now();

				Exemplo:

				Instant date = Instant.now();

			Instant (data com horário manual em EPOCH time - segundos)

				Instant <nome da variavel> = Instant.ofEpochSecond(<data em EPOCH time - segundos>);

				Exemplo:

				Instant date = Instant.ofEpochSecond(1678449000);

	Conversão data > texto

		Para converter no formato padrão ISO 8601 basta utilizar o método "toString".

		Exemplo:

			System.out.println(data.toString());

		Para converter em um formato "customizado" basta utilizar o método "format" do objeto de data passando como parametro um objeto "DateTimeFormatter".

		Para utilizar este objeto precisamos importar a classe "java.time.format.DateTimeFormatter".

		O objeto "DateTimeFormatter" determina a máscara utilizada para a conversão.

		Exemplo:

			DateTimeFormatter dtf = DateTimeFormatter.ofPattern("dd/MM/yyyy");
			LocalDate date = LocalDate.now();
			System.out.println(date.format(dtf));

		Tambem podemos fazer o inverso, para converter em um formato "customizado" basta utilizar o método "format" do objeto "DateTimeFormatter" passando como parametro um objeto de data.

		Exemplo:

			DateTimeFormatter dtf = DateTimeFormatter.ofPattern("dd/MM/yyyy");
			LocalDate date = LocalDate.now();
			System.out.println(dtf.format(date));

		Para formatar a partir de um Instant é necessario passar o timezone na criação do formatador e ao aplicar devemos fazer no modo inverso, aplicando o formatador a data.

		O timezone pode ser o local com ".withZone(ZoneId.systemDefault());".

		Exemplo:

			DateTimeFormatter dtf = DateTimeFormatter.ofPattern("dd/MM/yyyy").withZone(ZoneId.systemDefault());
			Instant date = Instant.now();
			System.out.println(dtf.format(date));

		Existem diversos formatadores prontos na classe "DateTimeFormatter" que podem ser utilizados.

		Exemplo:

			DateTimeFormatter dtf = DateTimeFormatter.ISO_LOCAL_DATE;
			DateTimeFormatter dtf = DateTimeFormatter.ISO_DATE_TIME;

	Conversão texto (formato padrão) > data

		Utilizar método "parse" das classes de data:

			<classe de data> <nome da variavel> = <classe de data>.parse("<data no formato texto>");

			Exemplos:

			LocalDate date = LocalDate.parse("2022-07-20");
			LocalDateTime date = LocalDateTime.parse("2022-07-20T01:30:26");
			Instant date = Instant.parse("2022-07-20T01:30:26Z");

		Conversão texto (formatos diferentes) > data

			Para a conversao de um texto (em formatos diferentes) para uma data precisamos utilizar um formatador da classe "DateTimeFormatter", especificamente seu método "ofPattern".

			Essa classe define formatos (máscaras) para conversão entre datas e texto, seu uso principal é para instanciar um objeto de data a partir de uma data em String.

			É necessario importar a classe "java.time.format.DateTimeFormatter" para seu uso.

			Funciona somente para LocalDate e LocalDateTime.

			Exemplo de declaração:

			DateTimeFormatter dtf;

			Exemplo de instanciação:

			dtf = DateTimeFormatter.ofPattern("<mascara>");

			Podemos instanciar com diversas máscaras, por exemplo:

			"dd/MM/yyyy"                   - 23/07/2018
			"dd/MM/yyyy HH:mm:ss"          - 23/07/2018 15:42:07
			"yyyy.MM.dd G 'at' HH:mm:ss z" - 2001.07.04 AD at 12:08:56 PDT
			"EEE, MMM d, ''yy"             - Wed, Jul 4, '01
			"h:mm a"                       - 12:08 PM
			"hh 'o''clock' a, zzzz"        - 12 o'clock PM, Pacific Daylight Time
			"K:mm a, z"                    - 0:08 PM, PDT
			"yyyyy.MMMMM.dd GGG hh:mm aaa" - 02001.July.04 AD 12:08 PM
			"EEE, d MMM yyyy HH:mm:ss Z"   - Wed, 4 Jul 2001 12:08:56 -0700
			"yyMMddHHmmssZ"                - 010704120856-0700
			"yyyy-MM-dd'T'HH:mm:ss.SSSZ"   - 2001-07-04T12:08:56.235-0700
			"yyyy-MM-dd'T'HH:mm:ss.SSSXXX" - 2001-07-04T12:08:56.235-07:00
			"YYYY-'W'ww-u"                 - 2001-W27-3

			As máscaras são criadas a partir da tabela abaixo:

			Symbol  Meaning                     Presentation      Examples

			G       era                         text              AD; Anno Domini; A
			u       year                        year              2004; 04
			y       year-of-era                 year              2004; 04
			D       day-of-year                 number            189
			M/L     month-of-year               number/text       7; 07; Jul; July; J
			d       day-of-month                number            10

			Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter
			Y       week-based-year             year              1996; 96
			w       week-of-week-based-year     number            27
			W       week-of-month               number            4
			E       day-of-week                 text              Tue; Tuesday; T
			e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T
			F       week-of-month               number            3

			a       am-pm-of-day                text              PM
			h       clock-hour-of-am-pm (1-12)  number            12
			K       hour-of-am-pm (0-11)        number            0
			k       clock-hour-of-am-pm (1-24)  number            0

			H       hour-of-day (0-23)          number            0
			m       minute-of-hour              number            30
			s       second-of-minute            number            55
			S       fraction-of-second          fraction          978
			A       milli-of-day                number            1234
			n       nano-of-second              number            987654321
			N       nano-of-day                 number            1234000000

			V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
			z       time-zone name              zone-name         Pacific Standard Time; PST
			O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00;
			X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15;
			x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15;
			Z       zone-offset                 offset-Z          +0000; -0800; -08:00;

		Criando um objeto de máscara de formatação:

		DateTimeFormatter dtf = DateTimeFormatter.ofPattern("dd/MM/yyyy");

		Aplicando um objeto de máscara de formatação:

		Ele é aplicado quando utilizado o método "parse" das classes de data, cocando o objeto DateTimeFormatter como um segundo argumento no momento da conversão.

		Exemplo:

		DateTimeFormatter dtf = DateTimeFormatter.ofPattern("dd/MM/yyyy");
		LocalDate date = LocalDate.parse("10/03/1979", dtf);
		
		DateTimeFormatter dtf = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");
		LocalDateTime date = LocalDateTime.parse("10/03/1979 11:55:47", dtf);

	Convertendo data-hora global para local

		Basta utilizar o método "ofInstant" informando como parametros o Instant e o zoneID.

		Exemplo:

		Instant instant = Instant.now();

		LocalDate date = LocalDate.ofInstant(instant, ZoneId.systemDefault());
		LocalDate date = LocalDate.ofInstant(instant, ZoneId.of("Portugal"));

		System.out.println(date);

	Extraindo informações de datas

		Utilizar o método "get" dos objetos de data, conforme necessidade.

		Objetos Instant nao possuem metodos get para hora devido ao UTC.

		Objetos LocalDate e LocalDateTIme possuem métodos get para dias e horas.

		Exemplo:

		LocalDateTime date = LocalDateTime.parse("2022-07-20T01:30:26");
		System.out.println("dia numero = " + date.getDayOfMonth());
		System.out.println("mes numero = " + date.getMonthValue());
		System.out.println("ano numero = " + date.getYear());
		System.out.println("dia do ano juliano = " + date.getDayOfYear());
		System.out.println("dia da semana texto = " + date.getDayOfWeek());
		System.out.println("mes texto = " + date.getMonth());
		System.out.println("hora = " + date.getHour());
		System.out.println("minuto = " + date.getMinute());
		System.out.println("segundo = " + date.getSecond());

	Efetuando calculo com datas

		Utilizar o método "plus" ou "minus" dos objetos de data, conforme necessidade, para adicionar ou subtrair periodos.

		Para objetos LocalDate e LocalDateTime os métodos são iguais, apenas temos metodos extras em LocalDateTime para horas, minutos e segundos.

		Exemplo:

		LocalDateTime data = LocalDateTime.parse("2022-07-20T01:30:26");
		LocalDateTime d01 = data.minusDays(7);
		LocalDateTime d02 = data.plusDays(7);
		LocalDateTime d03 = data.plusMonths(7);
		LocalDateTime d04 = data.plusYears(7);
		LocalDateTime d05 = data.plusHours(7);
		LocalDateTime d06 = data.plusMinutes(7);
		LocalDateTime d07 = data.plusSeconds(7);

		Para objetos Instance temos métodos "plus" ou "minus" porem precisamos de um argumento extra "ChronoUnit".

		Porem so temos métodos para dias, horas, minutos e segundos.

		Exemplo:

		Instant d14 = Instant.parse("2022-07-20T01:30:26Z");
		Instant d15 = d14.minus(7, ChronoUnit.DAYS);
		Instant d16 = d14.plus(7, ChronoUnit.DAYS);
		Instant d19 = d14.plus(7, ChronoUnit.HOURS);
		Instant d20 = d14.plus(7, ChronoUnit.MINUTES);
		Instant d21 = d14.plus(7, ChronoUnit.SECONDS);

		Para calcular a duração entre datas basta utilizar o método "between" da classe "Duration".

		Só funciona com Instant ou LocalDateTime, para utilizar com LocalDate é necessaria conversao.

		Exemplo:

		Instant nascimento = Instant.parse("1979-03-10T11:50:00Z");
		Instant hoje = Instant.now();
		Duration periodo = Duration.between(nascimento, hoje);
		System.out.println(periodo.toDays());

- Datas (versão Java v7 ou mais antiga)

	Classe "Date"

		Para datas em Java utilizamos a classe "Date", ela faz parte do pacote "java.util".

		Desta forma para utiliza-la devemos importar a classe da seguinte forma:

		import java.util.Date;

		Um objeto Date internamente armazena o número de milissegundos (tipo long) desde a meia noite do dia 1 de janeiro de 1970 (UTC - timezone GMT).

		A prática comum é salvar sempre as datas no formato UTC e efetuar a conversão para leitura / gravação conforme o timezone local.

		Exemplo de declaração:

		Date <nome da variável>;

		Podemos instanciar uma data de vária formas, por exemplo:

		new Date() - momento atual
		new Date(System.currentTimeMillis()) - momento atual
		new Date(<tempo em milisegundos>L) - momento que usa como referência os milisegundos a partir de "1 de janeiro de 1970 00:00:00"

		Mas o mais comum é instanciar um objeto Date partindo de uma data em String, para isso utilizamos uma classe de formatação de datas, a classe "SimpleDateFormat".

	Classe "SimpleDateFormat"

		Para formatação de datas utilizamos a classe "SimpleDateFormat", ela faz parte do pacote "java.text".

		Desta forma para utiliza-la devemos importar a classe da seguinte forma:

		import java.text.SimpleDateFormat;

		Essa classe define formatos (máscaras) para conversão entre Date e String, seu uso principal é para instanciar um objeto Date a partir de uma data em String ou para exibir um objeto Date em um formato específico.

		Exemplo de declaração:

		SimpleDateFormat sdf;

		Exemplo de instanciação:

		sdf = new SimpleDateFormat("<mascara>");

		Podemos instanciar com diversas máscaras, por exemplo:

		"dd/MM/yyyy"                   - 23/07/2018
		"dd/MM/yyyy HH:mm:ss"          - 23/07/2018 15:42:07
		"yyyy.MM.dd G 'at' HH:mm:ss z" - 2001.07.04 AD at 12:08:56 PDT
		"EEE, MMM d, ''yy"             - Wed, Jul 4, '01
		"h:mm a"                       - 12:08 PM
		"hh 'o''clock' a, zzzz"        - 12 o'clock PM, Pacific Daylight Time
		"K:mm a, z"                    - 0:08 PM, PDT
		"yyyyy.MMMMM.dd GGG hh:mm aaa" - 02001.July.04 AD 12:08 PM
		"EEE, d MMM yyyy HH:mm:ss Z"   - Wed, 4 Jul 2001 12:08:56 -0700
		"yyMMddHHmmssZ"                - 010704120856-0700
		"yyyy-MM-dd'T'HH:mm:ss.SSSZ"   - 2001-07-04T12:08:56.235-0700
		"yyyy-MM-dd'T'HH:mm:ss.SSSXXX" - 2001-07-04T12:08:56.235-07:00
		"YYYY-'W'ww-u"                 - 2001-W27-3

		As máscaras são criadas a partir da tabela abaixo:

		Letter 		Date or Time Component 									Presentation 				Examples

		G 			Era designator 											Text 						AD
		y 			Year 													Year 						1996; 96
		Y 			Week year 												Year 						2009; 09
		M 			Month in year 											Month 						July; Jul; 07
		w 			Week in year 											Number 						27
		W 			Week in month 											Number 						2
		D 			Day in year 											Number 						189
		d 			Day in month 											Number 						10
		F 			Day of week in month 									Number 						2
		E 			Day name in week 										Text 						Tuesday; Tue
		u 			Day number of week (1 = Monday, ..., 7 = Sunday) 		Number 						1
		a 			Am/pm marker 											Text 						PM
		H 			Hour in day (0-23) 										Number 						0
		k 			Hour in day (1-24) 										Number 						24
		K 			Hour in am/pm (0-11) 									Number 						0
		h 			Hour in am/pm (1-12) 									Number 						12
		m 			Minute in hour 											Number 						30
		s 			Second in minute 										Number 						55
		S 			Millisecond 											Number 						978
		z 			Time zone 												General time zone 			Pacific Standard Time; PST; GMT-08:00
		Z 			Time zone 												RFC 822 time zone 			-0800
		X 			Time zone 												ISO 8601 time zone 			-08; -0800; -08:00

		Criando um objeto Date:

		Utilizamos o método "parse" para transformar o texto em um objeto Date, por exemplo:

		Date date = sdf.parse("23/07/2018");

		Imprimindo um objeto Date:

		Utilizamos o método "format" para imprimir um objeto Date, por exemplo:

		System.out.println(sdf.format(data));

		Por padrão é utilizado o timezone local da máquina, para alterarmos devemos definir a configuração em um objeto "SimpleDateFormat" conforme abaixo:

		sdf.setTimeZone(TimeZone.getTimeZone("<timezone desejado>"));

		Por exemplo, timezone "GMT":

		sdf.setTimeZone(TimeZone.getTimeZone("GMT"));

		Esta alteração necessita do import da classe "java.util.TimeZone";

	Classe "Instant"

		A partir do Java versão 8 foram criadas novas classes para tratamento de datas, uma delas é a classe Instant.

		Éla é utilizada para transformar uma data texto no formato ISO 8601 (UTC) em objeto "Date".

		Desta forma para utiliza-la devemos importar a classe da seguinte forma:

		import java.time.Instant;

		O padrao utilizado para gravação de datas é o ISO 8601 que compreende o seguinte formato:

		yyyy-MM-ddTHH:mm:ssZ

		Exemplo:

		2018-06-25T15:42:07Z

		Utilizamos o seguinte modo de conversão:

		Date <nome da variável> = Date.from(Instant.parse("<data no formato texto ISO 8601"));

		Exemplo:

		Date date = Date.from(Instant.parse("2018-06-25T15:42:07Z"));

	Classe "Calendar"

		Para pegarmos informação especifica de uma data ou efetuarmos calculos com datas utilizamos a classe "Calendar", ela faz parte do pacote "java.util".

		Desta forma para utilza-la devemos importar a classe da seguinte forma:

		import java.util.calendar;

		Exemplo de declaração / instanciação:

		Calendar cal = Calendar.getInstance();

		Temos diversos usos para essa classe.

		Atribuindo uma data ao calendario:

		cal.setTime(<objeto Date>);

		Atribuindo uma data de calendário para um objeto Date:

		<objeto Date> = cal.getTime();

		Adicionando ou subtraindo tempo a data do calendario:

		cal.add(<o que será atribuido (verificar na documentação)>, <quantidade a ser atribuida ou subtraida com valor negativo>);	

		Exemplo:

		cal.add(Calendar.HOUR_OF_DAY, 4);

		Obtendo undiades de tempo de um calendario:

		cal.get(<o que será obtido (verificar na documentação)>);

		Exemplo:

		cal.get(Calendar.MINUTE);

		cal.get(Calendar.MONTH);

- Enumerações

	É um tipo especial que serve para especificar de forma literal um conjunto de constantes relacionadas.

	Palavra chave em Java: enum

	Vantagem: melhor semântica, código mais legível e auxiliado pelo compilador

	Em um caso comum ela é utilizada para substituir uma variavel array de uma classe que contenha caracteristicas de um objeto e essas caracterisiticas são fixas.

	A enums ficam no pacote "entities.enums";

	Ela é declarada da seguinte forma:

		package entities.enums;

		public enum <nome da enum> {
			<itens da enum em letra maiuscula se preciso separar as palavras por _>,
			...
		}

	Exemplo:

		package entities.enums;

		public enum OrderStatus {
			PENDING_PAYMENT,
			PROCESSING,
			SHIPPED,
			DELIVERED;
		}

	Para utilizar basta importar a enum e declarar como uma variavel da seguinte forma:

		import entities.enums.<nome da enum>;
		....
		<modificador de acesso> <nome da enum> <nome da variavel>;

	Exemplo:

		import entities.enums.OrderStatus;
		...
		private OrderStatus status;

	O acesso a uma constante da enum é feito da seguinte forma:

		<nome da variavel enum>.<constante>;

	Exemplo:

		status.PENDING_PAYMENT;

	A conversão de String para enum é comum pois os sistemas podem informar os valores como String, devendo ser convertida utilizando o método "valueOf" da seguinte forma:

		<nome da classe enum>.valueOf("<string>");

		Exemplo:

		OrderStatus.valueOf("DELIVERED");

- Categorias de classes

	Em um sistema orientado a objetos, de modo geral "tudo" é objeto.

	Por questões de design tais como organização, flexibilidade, reuso, delegação, etc., há várias categorias de classes:

	Entities
	Controllers
	Services
	Views
	Repositories

- Composição de objetos (associações)

	É um tipo de associação que permite que um objeto contenha outro, sendo uma relação "tem-um" ou "tem-vários".

	Temos dois tipos de composição de objetos, "Agregação" e "Composição".

	Na Agregação, a existência do Objeto-Parte faz sentido, mesmo não existindo o Objeto-Todo.

	Na Composição a existência do Objeto-Parte não faz sentido se o Objeto-Todo não existir. 

	Na UML a relação de Agregação é mostrada com um losangulo de preenchimento na cor branca.

	Na UML a relação de Composição é mostrada com um losangulo de preenchimento na cor preta.

	Vantagens:

	Organização (divisão de responsabilidades)
	Coesão
	Flexibilidade
	Reuso

	Nota: embora o símbolo UML para composição (todo-parte) seja o diamante preto, neste contexto estamos chamando de composição qualquer associação tipo "tem-um" e "tem-vários".

	Sempre que tivermos uma composição "tem-varios" utilizamos a classe "List", a variável da mesma não é instanciada no construtor recebendo paramentro, ela é instanciada vazia no construtor.

	Exemplo:

		private List<HourContract> contracts;

		public Worker() {
			this.contracts = new ArrayList<HourContract>();
		}

	Esta mesma variável nao deve ter o método "set" configurado, e sim métodos "add" e "remove".

	Exemplo:

		public void addContract(HourContract contract) {
			contracts.add(contract);
		}
		
		public void removeContract(HourContract contract) {
			contracts.remove(contract);
		}

- Classe "StringBuilder"

	Essa classe permite criar e manipular dados de Strings dinamicamente, ou seja, podem criar variáveis de String modificáveis.

	O significado da classe StringBuilder não tem o mesmo sentido que classe String. Existe uma diferença entre essas classes, veja algumas características.

	Características StringBuilder

	    Armazena caracteres especificados pela sua capacidade, caso ela seja excedida, é aumentada para acomodar os caracteres adicionais
	    Não precisa alocar novos objetos quando realiza uma concatenação
	    Não são sincronizadas
	    Não são seguras para threads

	Uma vantagem sobre a classe String é a concatenação de strings. Pois quando concatena strings com StringBuilder é invocado o método append. Esse método aloca novas strings concatenadas para o mesmo objeto, ou seja, cada vez que concatena strings não são criadas cópias dos objetos como é realizado pelo método concat da classe String, contribuindo para um melhor desempenho do sistema.

	Exemplo de declaração:

		StringBuilder  sb;

	Exemplo de instanciação:

		sb = new StringBuilder();

	Métodos

		append("<text>") - adiciona o texto no final
		toString() - mostra o texto

- Herança

	É um tipo de associação que permite que uma classe herde todos atributos e métodos de outra classe, permitindo seu uso e eliminando a duplicidade de código.

	Na UML a relação de herança é mostrada com uma seta fechada com preenchimento na cor branca.

	Sintaxe de uso

		Ao declarar a subclasse devemos inserir a palavra "extends" e o nome da superclasse a frente, por exemplo:

		public class BusinessAccount extends Account {
			...
		}

	Construtor

		Devemos criar um construtor que contemple os atributos da superclasse e da subclasse.

		Na declaração do método inserimos todos os parametros.

		No inicio do método chamamos o construtor da superclasse com a palavra "super" e em seguida passamos os parametros necessarios do construtor da superclasse.

		Em seguida inicializamos os atributos da subclasse.

		Exemplo:

		public BusinessAccount(Integer number, String holder, Double balance, Double loanLimit) {
			super(number, holder, balance);
			this.loanLimit = loanLimit;
		}

	Definições importantes

		A relação entre a subclasse e a superclasse é "é-um".

		Quando olhamos o diagrama UML da subclasse para a superclasse falamos que é uma generalização, quando olhamos o diagrama UML da superclasse para a subclasse falamos que é uma especialização.

		A classe que recebe a herança é chamada de subclasse e a classe que ofere a herança é a superclasse.

		A aplicação da herança é considerada um extensão da classe original. 

		Herança é uma associação entre classes (e não entre objetos).

		O modificador "private" nos atributos da superclasse impede o acesso direto aos mesmos pela subclasse, temos duas formas de contornar essa situação, utilizando os métodos getters e setters da classe ou mudando o modificador para "protected".

- Upcasting e downcasting

	Upcasting e downcasting são a conversão entre objetos.

	O uso comum do upcasting e downcasting é o polimorfismo.

	Toda subclasse "é uma" superclasse, o contrario não se aplica.

	Upcasting é a conversão de um ojeto da subclasse para a superclasse, ela é feita de forma implicita pois toda subclasse "é uma" superclasse.

	Exemplo:

		BusinessAccount bacc = new BusinessAccount(1002, "Maria", 0.0, 500.0);
		Account acc = bacc;

	Downcasting é a converção de um ojeto da superclasse para a subclasse, ela é feita de forma explicita porém so pode ser feita se a classe a ser convertida for compativel com a classe que irá receber a variável, pois nenhuma superclasse é uma subclasse, caso contrario sera exibido erro de execução "cannot be cast".

	Exemplo:

		* Permitido

		Account acc = new BusinessAccount(1003, "Bob", 0.0, 200.0); // Variavel "Account" instanciada como "BusinessAccount", sendo compativel a conversão explicita
		BusinessAccount bacc = (BusinessAccount) acc;

		* Erro

		Account acc = new Account(1003, "Bob", 0.0); // Variavel "Account" instanciada como "Account", não, sendo compativel a conversão explicita
		BusinessAccount bacc = (BusinessAccount) acc;

	Palavra "instanceof"

		Antes de efetuar um downcasting e correr o risco de receber uma mensagem de erro podemos comparar se um objeto é compativel utilizando a palavra "instanceof" e uma estrutura "if".

		Exemplo:

		if (acc instanceof BusinessAccount) {
			BusinessAccount bacc = (BusinessAccount) acc;
			...
		}

- Sobreposição / sobrescrita de métodos

	É a reimplementação de um método de uma superclasse na subclasse, com lógica diferente.

	Para utilizar primeiramente inserimos a anotação "@Override", isso facilita a leitura e compreensão do código e avisa ao compilador que o método é uma sobreposição.

	Em seguida basta copiar a assinatura do método original (declaração) e inserir a lógica desejada no mesmo.

	O método "toString" é uma sobreposição por exemplo, ele sobrescreve o método "toString" da classe "Object", inserindo uma lógica diferente.

	Exemplo:

	@override
	public String toString() {
		return ...
	}

- Palavra "super" em sobreposição / sobrescrita de métodos

	É possível chamar a implementação da superclasse na subclasse usando a palavra super, para isso, na sobreposição do método, inserir a palavra "super.<método a ser executado>", por exemplo:

	@Override
	public void withdraw(Double amount) {
		super.withdraw(amount);
		balance -= 2.0;
	}

- Classes e métodos "final"

	Para classes a palavra "final" define que aquela classe não pode ser herdada, a palavra deve ser inserida logo após o modificador de acesso, segue exemplo da declaração:

		public final class <nome da classe> {
		...
		})

	Para métodos a palavra "final" define que aquele método não pode ser sobrescrito, a palavra deve ser inserida logo após o modificador de acesso, segue exemplo da declaração:

		public final void <nome do método>() {
		...
		})

	Uso da palavra "final"

		Segurança, dependendo das regras do negócio, às vezes é desejável garantir que uma classe não seja herdada, ou que um método não seja sobreposto.

		Geralmente convém acrescentar final em métodos sobrepostos, pois sobreposições múltiplas podem ser uma porta de entrada para inconsistências.

		Performance, atributos de tipo de uma classe final são analisados de forma mais rápida em tempo de execução.

- Polimorfismo

	Pilares da OOP:

	Encapsulamento
	Herança
	Polimorfismo

	Em Programação Orientada a Objetos, polimorfismo é recurso que permite que variáveis de um mesmo tipo mais genérico possam apontar para objetos de tipos específicos diferentes, tendo assim comportamentos diferentes conforme cada tipo específico.

	Exemplo:

	Account x = new Account(1020, "Alex", 1000.0); // Variavel do tipo Account instanciada com um tipo Account
	Account y = new SavingsAccount(1023, "Maria", 1000.0, 0.01); // Variavel do tipo Account instanciada com um tipo SavingsAccount

	x.withdraw(50.0); // Irá chamar o método do objeto Account
	y.withdraw(50.0); // Irá chamar o método do objeto SavingsAccount

	Importante entender que a associação do tipo específico com o tipo genérico é feita em tempo de execução (upcasting).

- Classes abstratas

	São classes que não podem ser instanciadas.

	É uma forma de garantir herança total, somente subclasses não abstratas podem ser instanciadas, mas nunca a superclasse abstrata.

	Sintaxe:

	Basta acrescentarmos a palavra "abstract" na declaração da classe após o modificador de acesso, exemplo:

		public abstract class <nome da classe> {
			...
		}

	Na notação UML o nome da classe abstrata é escrito em itálico.

	Principais usos de classes abstratas:

	Reuso de código (herança)

	Polimorfismo, a superclasse classe genérica nos permite tratar de forma fácil e uniforme todos os tipos de objetos, inclusive com polimorfismo se for o caso. Por exemplo, você pode colocar todos tipos de objetos em uma mesma coleção.

- Métodos abstratos

	São métodos que não possuem implementação, somente sua ssinatura (declaração).

	Métodos precisam ser abstratos quando a classe é genérica demais para conter sua implementação.

	Se uma classe possuir pelo menos um método abstrato, então esta classe também é abstrata.

	Sintaxe:

	Basta acrescentarmos a palavra "abstract" na declaração do método após o modificador de acesso e removermos as chaves que delimitam o corpo do kmétodo, exemplo:

		public abstract void <nome do método>();

	Na notação UML o nome do método abstrato é escrito em itálico.

- Exceções

	Uma exceção é qualquer condição de erro ou comportamento inesperado encontrado por um programa em execução.

	Em Java, uma exceção é um objeto herdado da classe, segue hierarquia básica:

		java.lang.Throwable
		    java.lang.Exception
		    java.lang.RuntimeException

	Erros da classe "java.lang.Exception" o compilador obriga a tratar ou propagar.

	Erros da classe "java.lang.RuntimeException" compilador não obriga a tratar ou propagar.

	Quando lançada, uma exceção é propagada na pilha de chamadas de métodos em execução, até que seja capturada (tratada) ou o programa seja encerrado.

	Por que exceções?

		O modelo de tratamento de exceções permite que erros sejam tratados de forma consistente e flexível, usando boas práticas.

	Vantagens:

		Delega a lógica do erro para a classe responsável por conhecer as regras que podem ocasionar o erro.
		Trata de forma organizada (inclusive hierárquica) exceções de tipos diferentes.
		A exceção pode carregar dados quaisquer.
		Construtores podem ter tratamento de exceções.
		Possibilidade de auxílio do compilador (Exception).
		Código mais simples. Não há aninhamento de condicionais: a qualquer momento que uma exceção for disparada, a execução é interrompida e cai no bloco catch correspondente.
		É possível capturar inclusive outras exceções de sistema.

	Estrutura "try-catch"

		O bloco "try" contém o código que representa a execução normal do trecho de código que pode acarretar em uma exceção.

		O bloco "catch" contém o código a ser executado caso uma exceção ocorra, devendo ser especificado o tipo da exceção a ser tratada (upcasting é permitido).

		Devemos ter somente um bloco "try" porem podemos ter diversos blocos "catch" associados, cada um capturando uma exceção diferente.

		Sintaxe:

			try {
				<codigo que pode disparar uma exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			...

	Bloco "finally"

		É um bloco que contém código a ser executado independentemente de ter ocorrido ou não uma exceção, ele é sempre colocado ao final da estrutura try-catch.

		Exemplo de uso: fechar um arquivo, conexão de banco de dados, ou outro recurso específico ao final do processamento.

		Sintaxe:

			try {
				<codigo que pode disparar uma exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			catch (<tipo da exceção> e) {
				<tratativa da exceção>
			}
			...
			finally {
				<código a ser executado independente do resultado das condições anteriores>
			}

	Pilha de chamadas de métodos

		Ao ser lançada uma exceção ela mostra a pilha de chamada de métodos e encerra o programa, por exemplo:

			java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 3
			at application.Program.method2(Program.java:33)
			at application.Program.method1(Program.java:19)
			at application.Program.main(Program.java:11)

		Vemos na sequencia inversa os métodos chamados que implicaram em erro:

			at application.Program.method2(Program.java:33)
			at application.Program.method1(Program.java:19)
			at application.Program.main(Program.java:11)

		Caso a exceção seja capturada, se quisermos podemos ver esta pilha de chamada de métodos, basta chamar o método abaixo na variável que capturou a exceção:

			<variável>.printStackTrace();

		Caso a exceção seja capturada, se quisermos podemos ver esta a mensagem de erro, basta chamar o método abaixo na variável que capturou a exceção:

			<variável>.getMessage();

	Cláusula "throws"

		Propaga a exceção ao invés de tratá-la, é inserida na declaração do método que pode lançar a exceção, por exemplo:

		<declaração do método> throws <exceção que pode ser lançada {
			...
		}

		public void updateDates(Date checkIn, Date checkOut) throws DomainException {
			...
		}

	Cláusula "throw"

		Lança uma exceção, finalizando o método e devolvendo a exceção ao método que o chamou, por exemplo:

		throw new <nome da exceção>("<menagem de exceção>");

		throw new DomainException("Reservation dates for update must be future dates");

	Criação de exceção personalizada

		Podemos criar nossas proprias exceções, para isso basta criar uma classe no pacote "model.exceptions".

		Esta classe deve receber a herança de uma classe de exceção, como "RuntimeException" ou "Exception".

		Em corpo declaramos o "serialVersionUID".

		Em seguida criamos o construtor que recebe uma mensagem String e passa este parametro ao construtor da classe pai.

		Exemplo:

		package model.exceptions;

		public class <nome da exceção a ser criada> extends <nome da exceção que fornecera a herança> {

			private static final long serialVersionUID = <valor>;

			public <nome da exceção a ser criada>(String message) {
				super(message);
			}
			
		}

		Exemplo prático:

		package model.exceptions;

		public class DomainException extends RuntimeException {

			private static final long serialVersionUID = 1L;

			public DomainException(String message) {
				super(message);
			}
			
		}

		Apos a criação da exceção basta importar ela nas classes que forem utiliza-la e lançar a exceção com a clausula "throw".

		Por padrão as classes de exceção possuem a palavra "Exception" em seu nome, por exemplo "DomainException".

	Bloco "try-with-resources"

		É um bloco try que declara um ou mais recursos, e garante que esses recursos serão fechados ao final do bloco, sem a necessidade de fechar em um bloco finally.

		Declaração:

			Ao criar o bloco "try" passar como parametros os objetos que devem ser fechados ao final do bloco.

			Exemplo:

			try (BufferedReader br = new BufferedReader(new FileReader(path))) {
			
				String line = br.readLine();
				
				while (line != null) {
					System.out.println(line);
					line = br.readLine();
				}
				
			} catch (IOException e) {
				System.out.println(e.getMessage());
			}

		Desta forma evitamos criar um bloco finally que pode lançar exceções, por exemplo:

		} finally {
			
			try {
			
				if (br != null) {
					br.close();
				}
				if (fr != null) {
					fr.close();
				}
			
			} catch (IOException e) {
				e.printStackTrace();
			}
			
		}

- Trabalhando com arquivos e pastas

	Para trabalhar com pastas e arquivos utilizamos a classe "File" que é uma abstração de uma pasta ou arquivo.

	Gravação e leitura de arquivos

		Lendo os dados do arquivo (com a classe BufferedReader e FileReader, alta performance):

			Para trabalhar com a leitura de arquivos com uma performance maior utilizamos as classes FileReader (stream de leitura de arquivo) e BufferedReader (implementação de leitura de stream de arquivo com melhor performance).

			Utilizamos o método "readLine()" da classe BufferedReader para ler uma linha do arquivo.

			Como fazer:

			Criar um objeto String com o caminho do arquivo.

			Criar um objeto FileReader como "null".

			Criar um objeto BufferedReader como "null".

			Abrir um bloco "try".

			Instanciar o FiledReader passando como parametro a variavel String com o caminho do arquivo.

			Instanciar o BufferedReader passando como parametro o FileReader.

			Criar uma variavel String para ler a primeira linha do arquivo com o método "readLine()" da classe BufferedReader.

			Criar uma estrutura de repetição "while" para ler as linhas do arquivo.

			Dentro da estrutura utilizar o método "readLine()" da classe BufferedReader para ler a proxima linha do arquivo.

			Capturar a exceção IOException.

			Criar um bloco finally.

			Fechar os objetos FileReader e BufferdeReader para liberar o arquivo, porem dentro de outro bloco "try" pois podem lançar exceções.

			Exemplo:

			String path = "C:\\Temp\\in.txt";
			FileReader fr = null;
			BufferedReader br = null;
			
			try {
				
				fr = new FileReader(path);
				br = new BufferedReader(fr);
				
				String line = br.readLine();
				
				while (line != null) {
					System.out.println(line);
					line = br.readLine();
				}
				
			} catch (IOException e) {
				System.out.println(e.getMessage());
			} finally {
				
				try {
				
					if (br != null) {
						br.close();
					}
					if (fr != null) {
						fr.close();
					}
				
				} catch (IOException e) {
					e.printStackTrace();
				}
				
			}

		Gravando os dados no arquivo (com a classe BufferedWriter e FileWriter, alta performance):

			Para trabalhar com a gravação de arquivos com uma performance maior utilizamos as classes FileWriter (stream de gravação de arquivo) e BufferedWriter (implementação de gravação de stream de arquivo com melhor performance).

			Utilizamos o método "writeLine()" da classe BufferedWriter para gravar uma linha do arquivo.

			Temos duas opções de instanciação de um FileWriter:

			Cria/recria o arquivo: new FileWriter(<caminho do arquivo>)
			Acrescenta ao arquivo existente: new FileWriter(<caminho do arquivo>, true)

			Como fazer:

			Criar um objeto array de String com os dado a serem gravados.

			Criar um objeto String com o caminho do arquivo que receberá os dados.

			Criar um objeto FileWriter como "null".

			Criar um objeto BufferedWriter como "null".

			Abrir um bloco "try".

			Instanciar o FiledWriter passando como parametro a variavel String com o caminho do arquivo.

			Instanciar o BufferedWriter passando como parametro o FileReader.

			Criar uma estrutura de repetição "for" para ler as linhas do do objeto String criado com os dados.

			Dentro da estrutura gravar a linha lida no arquivo com o método "writeLine()" da classe BufferedWriter.

			A gravação não efetua quebra de linha, sendo necessaria efetuar manualmente com o método "newLine()" da classe BufferedWriter.

			Capturar a exceção IOException.

			Criar um bloco finally.

			Fechar os objetos FileWriter e BufferdeWriter para liberar o arquivo, porem dentro de outro bloco "try" pois podem lançar exceções.

			Exemplo:

			String[] lines = new String[] {"Bom dia", "Boa tarde", "Boa noite"};
			String path = "C:\\temp\\out.txt";
			FileWriter fw = null;
			BufferedWriter bw = null;
			
			try {
				
				fw = new FileWriter(path, true);
				bw = new BufferedWriter(fw);
				
				for (String line : lines) {
					bw.write(line);
					bw.newLine();
				}
				
			} catch (IOException e) {
				System.out.println(e.getMessage());
			} finally {
				
				try {
				
					if (bw != null) {
						bw.close();
					}
					if (fw != null) {
						fw.close();
					}
				
				} catch (IOException e) {
					e.printStackTrace();
				}
				
			}

	Gravação e leitura de pastas

		Listar pastas / arquivos

			Para listar pastas e arquivos utilizamos a classe "File" que é uma abstração de uma pasta, especificamente seu método "listFiles()".

			Para mostrar as pastas passamos o parametro "File::isDirectory" ao método.

			Para mostrar os arquivos passamos o parametro "File::isFile" ao método.

			Para mostrar os arquivos e pastas basta não passar nenhum parametro ao método.

			Exemplo:

				Scanner sc = new Scanner(System.in);
		
				System.out.print("Enter a folder path: ");
				String folderPath = sc.nextLine();
				
				File path = new File(folderPath);
				
				File[] folders = path.listFiles(File::isDirectory);
				System.out.println("Folders:");
				for (File folder : folders) {
					System.out.println(folder);
				}

				File[] files = path.listFiles(File::isFile);
				System.out.println("Files:");
				for (File file : files) {
					System.out.println(file);
				}
				
				File[] filesAndFolders = path.listFiles();
				System.out.println("Files and folders:");
				for (File item : filesAndFolders) {
					System.out.println(item);
				}

		Criar pastas e arquivos

			Para criar pastas e arquivos utilizamos a classe "File" que é uma abstração de uma pasta ou arquivo.

			Para criação de arquivo utilizamos o método "createNewFile()" da classe BufferedWriter.

			Para criação de arquivo utilizamos o método "mkdir()" da classe BufferedWriter.

			Exemplos:

			//Criando arquivo
			String fileName = "NovoArquivo.txt";
			File novoArquivo = new File(folderPath + "\\" + fileName);
			try {
				if (novoArquivo.createNewFile()) {
					System.out.println("Arquivo criado com sucesso!");
				} else {
					System.out.println("Erro na criação do arquivo...");
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		
			// Criando pasta
			String folderName = "NovaPasta";
			File novaPasta = new File(folderPath + "\\" + folderName);
			if (novaPasta.mkdir()) {
				System.out.println("Pasta criada com sucesso!");
			} else {
				System.out.println("Erro na criação da pasta...");
			}

			A pasta ou arquivo será criado somente se não existir nenhum destes itens com o mesmo nome, caso existam eles não são criados, snedo assim não ocorre sobrescrita.

	Métodos para arquivos

		Caso seja instanciado um arquivo com a classe File podemos usar os métodos abaixo para coletar informações:

		getName() - retorna o nome do arquivo
		getParent() - retorna a pasta onde esta o arquivo
		getPath() - retorna o caminho completo do arquivo
